import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:intl/intl.dart';
import '../widgets/interactive_map_improved.dart';
import '../services/map_service.dart';
import '../services/db_helper.dart';
import '../models/room_model.dart';
import '../models/reg_data.dart';
import 'test_map_display.dart';

class AccommodationBookingScreen extends StatefulWidget {
  const AccommodationBookingScreen({super.key});

  @override
  State<AccommodationBookingScreen> createState() =>
      _AccommodationBookingScreenState();
}

class _AccommodationBookingScreenState
    extends State<AccommodationBookingScreen> {
  final MapService _mapService = MapService();
  final DbHelper _dbHelper = DbHelper();

  MapData? _selectedMap;
  List<Room> _rooms = [];
  DateTime _selectedDate = DateTime.now();
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadMapAndRooms();
  }

  Future<void> _loadMapAndRooms() async {
    setState(() => _isLoading = true);

    try {
      // ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏±‡∏Å (active)
      final maps = await _mapService.getAllMaps();
      debugPrint('üìç ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ ${maps.length} ‡πÅ‡∏ú‡∏ô');

      _selectedMap = maps.where((map) => map.isActive).isNotEmpty
          ? maps.firstWhere((map) => map.isActive)
          : (maps.isNotEmpty ? maps.first : null);

      if (_selectedMap != null) {
        debugPrint('‚úÖ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà: ${_selectedMap!.name}');
        debugPrint('üñºÔ∏è ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û: ${_selectedMap!.hasImage}');
        if (_selectedMap!.hasImage) {
          debugPrint('üìÅ path ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û: ${_selectedMap!.imagePath}');
        }

        // ‡πÇ‡∏´‡∏•‡∏î‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏±‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        _rooms = await _mapService.getAllRooms();
        debugPrint('üè† ‡πÇ‡∏´‡∏•‡∏î‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏±‡∏Å‡πÑ‡∏î‡πâ ${_rooms.length} ‡∏´‡πâ‡∏≠‡∏á');

        for (var room in _rooms) {
          debugPrint(
            '   - ‡∏´‡πâ‡∏≠‡∏á ${room.name}: (${room.positionX}, ${room.positionY})',
          );
        }

        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
        await _updateRoomStatusForDate(_selectedDate);
      } else {
        debugPrint('‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö');
      }
    } catch (e) {
      debugPrint('‚ùå Error loading map and rooms: $e');
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _updateRoomStatusForDate(DateTime date) async {
    try {
      final dateStr = DateFormat('yyyy-MM-dd').format(date);

      for (int i = 0; i < _rooms.length; i++) {
        final room = _rooms[i];

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
        final bookings = await _getBookingsForRoomAndDate(room.id!, dateStr);

        if (bookings.isNotEmpty) {
          // ‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß - ‡∏™‡∏µ‡πÅ‡∏î‡∏á
          _rooms[i] = room.copyWith(status: RoomStatus.occupied);
        } else {
          // ‡∏´‡πâ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á - ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß
          _rooms[i] = room.copyWith(status: RoomStatus.available);
        }
      }

      setState(() {});
    } catch (e) {
      debugPrint('Error updating room status: $e');
    }
  }

  Future<List<Map<String, dynamic>>> _getBookingsForRoomAndDate(
    int roomId,
    String date,
  ) async {
    final db = await _dbHelper.db;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    return await db.query(
      'room_bookings',
      where:
          'room_id = ? AND check_in_date <= ? AND check_out_date >= ? AND status != ?',
      whereArgs: [roomId, date, date, 'cancelled'],
    );
  }

  Future<void> _onRoomTapped(Room room) async {
    if (room.status != RoomStatus.available) {
      await _showRoomManagementDialog(room);
      return;
    }

    await _showBookingDialog(room);
  }

  Future<void> _showRoomManagementDialog(Room room) async {
    if (room.status == RoomStatus.occupied) {
      // ‡∏´‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ú‡∏π‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å - ‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£
      await _showOccupiedRoomDialog(room);
    } else {
      // ‡∏´‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô - ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤
      _showSimpleUnavailableDialog(room);
    }
  }

  void _showSimpleUnavailableDialog(Room room) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('‡∏´‡πâ‡∏≠‡∏á ${room.name}'),
        content: const Text('‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('‡∏ï‡∏Å‡∏•‡∏á'),
          ),
        ],
      ),
    );
  }

  Future<void> _showOccupiedRoomDialog(Room room) async {
    // ‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ
    final occupantInfo = await _getRoomOccupantInfo(room.id!, _selectedDate);

    if (occupantInfo == null) {
      _showSimpleUnavailableDialog(room);
      return;
    }

    if (!mounted) return;

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('‡∏´‡πâ‡∏≠‡∏á ${room.name}'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '‡∏ú‡∏π‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å: ${occupantInfo['first_name']} ${occupantInfo['last_name']}',
            ),
            Text('‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£: ${occupantInfo['phone']}'),
            Text(
              '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å: ${_formatDate(occupantInfo['check_in_date'])}',
            ),
            Text('‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å: ${_formatDate(occupantInfo['check_out_date'])}'),
            const SizedBox(height: 16),
            const Text(
              '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£?',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'),
          ),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(context);
              await _showExtendStayDialog(occupantInfo);
            },
            child: const Text('‡∏Ç‡∏¢‡∏≤‡∏¢‡∏ß‡∏±‡∏ô‡∏û‡∏±‡∏Å'),
          ),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(context);
              await _showChangeRoomDialog(occupantInfo, room);
            },
            child: const Text('‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏´‡πâ‡∏≠‡∏á'),
          ),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(context);
              await _showCancelBookingDialog(occupantInfo, room);
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á'),
          ),
        ],
      ),
    );
  }

  String _formatDate(String dateStr) {
    try {
      final date = DateTime.parse(dateStr);
      return DateFormat('dd/MM/yyyy', 'th').format(date);
    } catch (e) {
      return dateStr;
    }
  }

  Future<Map<String, dynamic>?> _getRoomOccupantInfo(
    int roomId,
    DateTime date,
  ) async {
    try {
      final db = await _dbHelper.db;
      final dateStr = DateFormat('yyyy-MM-dd').format(date);

      final result = await db.rawQuery(
        '''
        SELECT rb.*, r.first AS first_name, r.last AS last_name, r.phone
        FROM room_bookings rb
        INNER JOIN regs r ON rb.visitor_id = r.id
        WHERE rb.room_id = ? 
          AND rb.check_in_date <= ? 
          AND rb.check_out_date >= ?
          AND rb.status != 'cancelled'
        LIMIT 1
      ''',
        [roomId, dateStr, dateStr],
      );

      return result.isNotEmpty ? result.first : null;
    } catch (e) {
      debugPrint('Error getting room occupant info: $e');
      return null;
    }
  }

  Future<void> _showExtendStayDialog(Map<String, dynamic> occupantInfo) async {
    final currentCheckOut = DateTime.parse(occupantInfo['check_out_date']);
    DateTime? newCheckOutDate = currentCheckOut;

    if (!mounted) return;

    final result = await showDialog<DateTime>(
      context: context,
      builder: (dialogContext) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: Text(
            '‡∏Ç‡∏¢‡∏≤‡∏¢‡∏ß‡∏±‡∏ô‡∏û‡∏±‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${occupantInfo['first_name']} ${occupantInfo['last_name']}',
          ),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: ${_formatDate(occupantInfo['check_out_date'])}',
              ),
              const SizedBox(height: 16),
              const Text(
                '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å‡πÉ‡∏´‡∏°‡πà:',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              InkWell(
                onTap: () {
                  debugPrint('üìÖ ‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏è‡∏¥‡∏ó‡∏¥‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà...');

                  // ‡πÉ‡∏ä‡πâ WidgetsBinding ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤ context ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
                  WidgetsBinding.instance.addPostFrameCallback((_) async {
                    try {
                      // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏î‡πâ
                      final firstAvailableDate = currentCheckOut.add(
                        const Duration(days: 1),
                      );

                      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ newCheckOutDate ‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ firstAvailableDate
                      DateTime initialDate;
                      if (newCheckOutDate != null &&
                          newCheckOutDate!.isAfter(
                            firstAvailableDate.subtract(
                              const Duration(days: 1),
                            ),
                          )) {
                        initialDate = newCheckOutDate!;
                      } else {
                        initialDate = firstAvailableDate;
                      }

                      debugPrint('üìÖ currentCheckOut: $currentCheckOut');
                      debugPrint('üìÖ firstAvailableDate: $firstAvailableDate');
                      debugPrint('üìÖ initialDate: $initialDate');

                      final picked = await showDatePicker(
                        context: context,
                        initialDate: initialDate,
                        firstDate: firstAvailableDate,
                        lastDate: DateTime.now().add(const Duration(days: 365)),
                        locale: const Locale('th'),
                      );
                      debugPrint('üìÖ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: $picked');
                      if (picked != null) {
                        setState(() {
                          newCheckOutDate = picked;
                        });
                      }
                    } catch (e) {
                      debugPrint('‚ùå Error showing date picker: $e');
                      // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° error ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏£‡∏≤‡∏ö
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            content: Text('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏è‡∏¥‡∏ó‡∏¥‡∏ô: $e'),
                            backgroundColor: Colors.red,
                          ),
                        );
                      }
                    }
                  });
                },
                child: Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.grey),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.calendar_today),
                      const SizedBox(width: 8),
                      Text(
                        newCheckOutDate == null
                            ? '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà'
                            : _formatDate(newCheckOutDate!.toIso8601String()),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'),
            ),
            ElevatedButton(
              onPressed: newCheckOutDate == null
                  ? null
                  : () => Navigator.pop(context, newCheckOutDate),
              child: const Text('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å'),
            ),
          ],
        ),
      ),
    );

    if (result != null) {
      await _updateCheckOutDate(occupantInfo, result);
    }
  }

  Future<void> _updateCheckOutDate(
    Map<String, dynamic> occupantInfo,
    DateTime newCheckOutDate,
  ) async {
    try {
      final db = await _dbHelper.db;
      final newCheckOutStr = DateFormat('yyyy-MM-dd').format(newCheckOutDate);

      // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï room_bookings table
      await db.update(
        'room_bookings',
        {'check_out_date': newCheckOutStr},
        where: 'id = ?',
        whereArgs: [occupantInfo['id']],
      );

      // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á reg_additional_info ‡∏î‡πâ‡∏ß‡∏¢
      await db.update(
        'reg_additional_info',
        {'endDate': newCheckOutStr},
        where: 'regId = ?',
        whereArgs: [occupantInfo['visitor_id']],
      );

      // ‡∏£‡∏µ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á
      await _updateRoomStatusForDate(_selectedDate);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              '‡∏Ç‡∏¢‡∏≤‡∏¢‡∏ß‡∏±‡∏ô‡∏û‡∏±‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å‡πÉ‡∏´‡∏°‡πà: ${_formatDate(newCheckOutStr)}',
            ),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      debugPrint('Error updating check out date: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ç‡∏¢‡∏≤‡∏¢‡∏ß‡∏±‡∏ô‡∏û‡∏±‡∏Å'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _showChangeRoomDialog(
    Map<String, dynamic> occupantInfo,
    Room currentRoom,
  ) async {
    // ‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡πâ‡∏≤‡∏¢
    final availableRooms = await _getAvailableRoomsForTransfer(occupantInfo);

    if (availableRooms.isEmpty) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏´‡πâ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡πâ‡∏≤‡∏¢')),
        );
      }
      return;
    }

    if (!mounted) return;

    Room? selectedRoom;

    final result = await showDialog<Room>(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: Text(
            '‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${occupantInfo['first_name']} ${occupantInfo['last_name']}',
          ),
          content: SizedBox(
            width: double.maxFinite,
            height: 300,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: ${currentRoom.name}'),
                const SizedBox(height: 16),
                const Text(
                  '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà:',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                Expanded(
                  child: ListView.builder(
                    itemCount: availableRooms.length,
                    itemBuilder: (context, index) {
                      final room = availableRooms[index];
                      final isSelected = selectedRoom?.id == room.id;

                      return ListTile(
                        title: Text(room.name),
                        subtitle: Text(
                          '‡∏Ç‡∏ô‡∏≤‡∏î: ${room.size.name}, ‡∏à‡∏∏‡πÑ‡∏î‡πâ: ${room.capacity} ‡∏Ñ‡∏ô',
                        ),
                        leading: Container(
                          width: 40,
                          height: 40,
                          decoration: BoxDecoration(
                            color: isSelected ? Colors.blue : Colors.green,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Icon(Icons.hotel, color: Colors.white),
                        ),
                        selected: isSelected,
                        selectedTileColor: Colors.blue.shade50,
                        onTap: () {
                          setState(() {
                            selectedRoom = room;
                          });
                        },
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'),
            ),
            ElevatedButton(
              onPressed: selectedRoom == null
                  ? null
                  : () => Navigator.pop(context, selectedRoom),
              child: const Text('‡∏¢‡πâ‡∏≤‡∏¢‡∏´‡πâ‡∏≠‡∏á'),
            ),
          ],
        ),
      ),
    );

    if (result != null) {
      await _transferToNewRoom(occupantInfo, currentRoom, result);
    }
  }

  Future<List<Room>> _getAvailableRoomsForTransfer(
    Map<String, dynamic> occupantInfo,
  ) async {
    try {
      final checkInDate = occupantInfo['check_in_date'];
      final checkOutDate = occupantInfo['check_out_date'];

      final availableRooms = <Room>[];

      for (final room in _rooms) {
        if (room.id == occupantInfo['room_id']) continue; // ‡∏Ç‡πâ‡∏≤‡∏°‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏´‡πâ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢
        final conflicts = await _getBookingsForRoomAndDateRange(
          room.id!,
          checkInDate,
          checkOutDate,
        );

        if (conflicts.isEmpty) {
          availableRooms.add(room);
        }
      }

      return availableRooms;
    } catch (e) {
      debugPrint('Error getting available rooms for transfer: $e');
      return [];
    }
  }

  Future<List<Map<String, dynamic>>> _getBookingsForRoomAndDateRange(
    int roomId,
    String startDate,
    String endDate,
  ) async {
    final db = await _dbHelper.db;

    return await db.query(
      'room_bookings',
      where: '''
        room_id = ? AND status != 'cancelled' AND (
          (check_in_date <= ? AND check_out_date >= ?) OR
          (check_in_date <= ? AND check_out_date >= ?) OR
          (check_in_date >= ? AND check_out_date <= ?)
        )
      ''',
      whereArgs: [
        roomId,
        startDate,
        startDate,
        endDate,
        endDate,
        startDate,
        endDate,
      ],
    );
  }

  Future<void> _transferToNewRoom(
    Map<String, dynamic> occupantInfo,
    Room oldRoom,
    Room newRoom,
  ) async {
    try {
      final db = await _dbHelper.db;

      // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÑ‡∏õ‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
      await db.update(
        'room_bookings',
        {'room_id': newRoom.id},
        where: 'id = ?',
        whereArgs: [occupantInfo['id']],
      );

      // ‡∏£‡∏µ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á
      await _updateRoomStatusForDate(_selectedDate);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              '‡∏¢‡πâ‡∏≤‡∏¢‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏à‡∏≤‡∏Å ${oldRoom.name} ‡πÑ‡∏õ ${newRoom.name}',
            ),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      debugPrint('Error transferring to new room: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢‡∏´‡πâ‡∏≠‡∏á'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _showCancelBookingDialog(
    Map<String, dynamic> occupantInfo,
    Room room,
  ) async {
    if (!mounted) return;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '‡∏ú‡∏π‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å: ${occupantInfo['first_name']} ${occupantInfo['last_name']}',
            ),
            Text('‡∏´‡πâ‡∏≠‡∏á: ${room.name}'),
            Text(
              '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å: ${_formatDate(occupantInfo['check_in_date'])}',
            ),
            Text('‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≠‡∏Å: ${_formatDate(occupantInfo['check_out_date'])}'),
            const SizedBox(height: 16),
            const Text(
              '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
              style: TextStyle(fontWeight: FontWeight.bold, color: Colors.red),
            ),
            const SizedBox(height: 8),
            const Text(
              '‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ',
              style: TextStyle(color: Colors.grey),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('‡πÑ‡∏°‡πà‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _cancelBooking(occupantInfo);
    }
  }

  Future<void> _cancelBooking(Map<String, dynamic> occupantInfo) async {
    try {
      final db = await _dbHelper.db;

      // ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á room_bookings
      await db.delete(
        'room_bookings',
        where: 'id = ?',
        whereArgs: [occupantInfo['id']],
      );

      // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô reg_additional_info ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏û‡∏±‡∏Å
      await db.update(
        'reg_additional_info',
        {'location': null, 'endDate': null},
        where: 'regId = ?',
        whereArgs: [occupantInfo['visitor_id']],
      );

      // ‡∏£‡∏µ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á
      await _updateRoomStatusForDate(_selectedDate);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${occupantInfo['first_name']} ${occupantInfo['last_name']}',
            ),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      debugPrint('Error canceling booking: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _showBookingDialog(Room room) async {
    // ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ
    final availablePractitioners = await _getAvailablePractitioners(
      _selectedDate,
    );

    if (availablePractitioners.isEmpty) {
      _showErrorDialog(
        '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô',
      );
      return;
    }

    RegData? selectedPractitioner;

    if (!mounted) return;

    return showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: Text('‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á ${room.name}'),
          content: SizedBox(
            width: double.maxFinite,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${DateFormat('dd/MM/yyyy', 'th').format(_selectedDate)}',
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 16),
                const Text(
                  '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°:',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                Container(
                  height: 300,
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.grey.shade300),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: availablePractitioners.isEmpty
                      ? const Center(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(
                                Icons.people_outline,
                                size: 64,
                                color: Colors.grey,
                              ),
                              SizedBox(height: 16),
                              Text(
                                '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ\n‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏±‡∏Å‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ',
                                textAlign: TextAlign.center,
                                style: TextStyle(
                                  color: Colors.grey,
                                  fontSize: 16,
                                ),
                              ),
                            ],
                          ),
                        )
                      : ListView.builder(
                          itemCount: availablePractitioners.length,
                          itemBuilder: (context, index) {
                            final practitioner = availablePractitioners[index];
                            final isSelected =
                                selectedPractitioner?.id == practitioner.id;

                            return ListTile(
                              title: Text(
                                '${practitioner.first} ${practitioner.last}',
                              ),
                              subtitle: Text(
                                '‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£: ${practitioner.phone}\n'
                                '‡πÄ‡∏û‡∏®: ${practitioner.gender}',
                              ),
                              leading: CircleAvatar(
                                backgroundColor: isSelected
                                    ? Colors.blue
                                    : Colors.grey.shade300,
                                child: Text(
                                  practitioner.first.isNotEmpty
                                      ? practitioner.first[0]
                                      : '?',
                                  style: TextStyle(
                                    color: isSelected
                                        ? Colors.white
                                        : Colors.black54,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                              selected: isSelected,
                              selectedTileColor: Colors.blue.shade50,
                              onTap: () {
                                setState(() {
                                  selectedPractitioner = practitioner;
                                });
                              },
                            );
                          },
                        ),
                ),
                if (selectedPractitioner != null) ...[
                  const SizedBox(height: 12),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.green.shade50,
                      border: Border.all(color: Colors.green.shade200),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(Icons.check_circle, color: Colors.green.shade700),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: ${selectedPractitioner!.first} ${selectedPractitioner!.last}',
                            style: TextStyle(
                              color: Colors.green.shade700,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'),
            ),
            ElevatedButton(
              onPressed: selectedPractitioner == null
                  ? null
                  : () async {
                      Navigator.pop(context);
                      await _processBooking(room, selectedPractitioner!.id);
                    },
              child: const Text('‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á'),
            ),
          ],
        ),
      ),
    );
  }

  /// ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ
  Future<List<RegData>> _getAvailablePractitioners(
    DateTime selectedDate,
  ) async {
    try {
      final db = await _dbHelper.db;
      final dateStr = DateFormat('yyyy-MM-dd').format(selectedDate);

      // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà:
      // 1. ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (startDate <= selectedDate <= endDate)
      // 2. ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏±‡∏Å ‡∏´‡∏£‡∏∑‡∏≠‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô "‡∏®‡∏≤‡∏•‡∏≤‡πÉ‡∏´‡∏ç‡πà"
      final result = await db.rawQuery(
        '''
        SELECT DISTINCT r.*
        FROM regs r
        INNER JOIN reg_additional_info ai ON r.id = ai.regId
        WHERE r.status = 'A'
          AND (
            (ai.startDate IS NOT NULL AND ai.endDate IS NOT NULL AND ai.startDate <= ? AND ai.endDate >= ?) OR
            (ai.startDate IS NULL OR ai.endDate IS NULL)
          )
          AND r.id NOT IN (
            SELECT DISTINCT rb.visitor_id
            FROM room_bookings rb
            INNER JOIN rooms room ON rb.room_id = room.id
            WHERE rb.check_in_date <= ? 
              AND rb.check_out_date >= ?
              AND rb.status != 'cancelled'
              AND room.name != '‡∏®‡∏≤‡∏•‡∏≤‡πÉ‡∏´‡∏ç‡πà'
          )
        ORDER BY r.first, r.last
      ''',
        [dateStr, dateStr, dateStr, dateStr],
      );

      debugPrint('üìä Query for available practitioners on $dateStr:');
      debugPrint('   Found ${result.length} practitioners');

      if (result.isEmpty) {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ñ‡∏ô‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        final allRegs = await db.query(
          'regs',
          where: 'status = ?',
          whereArgs: ['A'],
        );
        debugPrint('   Total active registrations: ${allRegs.length}');

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        final allStays = await db.rawQuery(
          '''
          SELECT ai.*, r.first, r.last
          FROM reg_additional_info ai
          INNER JOIN regs r ON ai.regId = r.id
          WHERE r.status = 'A' AND ai.startDate <= ? AND ai.endDate >= ?
        ''',
          [dateStr, dateStr],
        );
        debugPrint('   People staying on $dateStr: ${allStays.length}');

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô reg_additional_info
        final allAdditionalInfo = await db.rawQuery('''
          SELECT ai.*, r.first, r.last
          FROM reg_additional_info ai
          INNER JOIN regs r ON ai.regId = r.id
          WHERE r.status = 'A'
        ''');
        debugPrint(
          '   All additional info records: ${allAdditionalInfo.length}',
        );

        for (var info in allAdditionalInfo) {
          debugPrint(
            '     - ${info['first']} ${info['last']}: ${info['startDate']} - ${info['endDate']} (regId: ${info['regId']})',
          );
        }

        for (var stay in allStays) {
          debugPrint(
            '     - ${stay['first']} ${stay['last']}: ${stay['startDate']} - ${stay['endDate']}',
          );
        }

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á
        final bookings = await db.rawQuery(
          '''
          SELECT rb.*, r.first, r.last, room.name as room_name
          FROM room_bookings rb
          INNER JOIN regs r ON rb.visitor_id = r.id
          INNER JOIN rooms room ON rb.room_id = room.id
          WHERE rb.check_in_date <= ? AND rb.check_out_date >= ? AND rb.status != 'cancelled'
        ''',
          [dateStr, dateStr],
        );
        debugPrint('   Existing bookings on $dateStr: ${bookings.length}');

        for (var booking in bookings) {
          debugPrint(
            '     - ${booking['first']} ${booking['last']} in ${booking['room_name']}',
          );
        }
      }

      return result.map((map) => RegData.fromMap(map)).toList();
    } catch (e) {
      debugPrint('Error getting available practitioners: $e');
      return [];
    }
  }

  Future<void> _processBooking(Room room, String idNumber) async {
    try {
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°‡∏Ñ‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      final practitioner = await _getPractitionerById(idNumber);
      if (practitioner == null) {
        _showErrorDialog('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡∏ô‡∏µ‡πâ');
        return;
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      final isCurrentlyStaying = await _isCurrentlyStaying(
        idNumber,
        _selectedDate,
      );
      if (!isCurrentlyStaying) {
        _showErrorDialog(
          '‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πâ\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô',
        );
        return;
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß
      final existingBooking = await _getExistingBookingForDate(
        idNumber,
        _selectedDate,
      );
      if (existingBooking != null) {
        _showErrorDialog(
          '‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°‡∏£‡∏≤‡∏¢‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏±‡∏Å‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏´‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏Å‡πà‡∏≠‡∏ô\n\n‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏≠‡∏á‡πÑ‡∏ß‡πâ: ${existingBooking['room_name']}',
        );
        return;
      }

      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á
      await _saveBooking(room, idNumber, practitioner);

      // ‡∏£‡∏µ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á
      await _updateRoomStatusForDate(_selectedDate);

      _showSuccessDialog(room, practitioner);
    } catch (e) {
      debugPrint('Error processing booking: $e');
      _showErrorDialog('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
    }
  }

  Future<RegData?> _getPractitionerById(String idNumber) async {
    final db = await _dbHelper.db;
    final result = await db.query(
      'regs',
      where: 'id = ? AND status = ?',
      whereArgs: [idNumber, 'A'],
    );

    return result.isNotEmpty ? RegData.fromMap(result.first) : null;
  }

  Future<bool> _isCurrentlyStaying(String idNumber, DateTime checkDate) async {
    final db = await _dbHelper.db;
    final dateStr = DateFormat('yyyy-MM-dd').format(checkDate);

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≤‡∏Å reg_additional_info ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    // ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà startDate ‡∏´‡∏£‡∏∑‡∏≠ endDate ‡πÄ‡∏õ‡πá‡∏ô null (‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ)
    final result = await db.query(
      'reg_additional_info',
      where: '''regId = ? AND (
        (startDate IS NOT NULL AND endDate IS NOT NULL AND startDate <= ? AND endDate >= ?) OR
        (startDate IS NULL OR endDate IS NULL)
      )''',
      whereArgs: [idNumber, dateStr, dateStr],
    );

    debugPrint(
      'üîç Checking stay status for $idNumber on $dateStr: ${result.isNotEmpty ? "ALLOWED" : "NOT ALLOWED"}',
    );
    if (result.isNotEmpty) {
      final record = result.first;
      debugPrint(
        '   - startDate: ${record['startDate']}, endDate: ${record['endDate']}',
      );
    }

    return result.isNotEmpty;
  }

  Future<Map<String, dynamic>?> _getExistingBookingForDate(
    String idNumber,
    DateTime checkDate,
  ) async {
    final db = await _dbHelper.db;
    final dateStr = DateFormat('yyyy-MM-dd').format(checkDate);

    final result = await db.rawQuery(
      '''
      SELECT rb.*, r.name as room_name 
      FROM room_bookings rb
      INNER JOIN rooms r ON rb.room_id = r.id
      WHERE rb.visitor_id = ? 
        AND rb.check_in_date <= ? 
        AND rb.check_out_date >= ?
        AND rb.status != ?
    ''',
      [idNumber, dateStr, dateStr, 'cancelled'],
    );

    return result.isNotEmpty ? result.first : null;
  }

  Future<void> _saveBooking(
    Room room,
    String idNumber,
    RegData practitioner,
  ) async {
    final db = await _dbHelper.db;
    final now = DateTime.now();
    final dateStr = DateFormat('yyyy-MM-dd').format(_selectedDate);

    await db.insert('room_bookings', {
      'room_id': room.id,
      'visitor_id': idNumber,
      'check_in_date': dateStr,
      'check_out_date': dateStr, // ‡∏à‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≤‡∏¢‡∏ß‡∏±‡∏ô
      'status': 'confirmed',
      'note': '‡∏à‡∏≠‡∏á‡∏ú‡πà‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö',
      'created_at': now.toIso8601String(),
      'updated_at': now.toIso8601String(),
    });
  }

  void _showErrorDialog(String message) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ'),
        content: Text(message),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('‡∏ï‡∏Å‡∏•‡∏á'),
          ),
        ],
      ),
    );
  }

  void _showSuccessDialog(Room room, RegData practitioner) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('‡∏´‡πâ‡∏≠‡∏á: ${room.name}'),
            Text('‡∏ú‡∏π‡πâ‡∏à‡∏≠‡∏á: ${practitioner.first} ${practitioner.last}'),
            Text(
              '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${DateFormat('dd/MM/yyyy', 'th').format(_selectedDate)}',
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('‡∏ï‡∏Å‡∏•‡∏á'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    debugPrint(
      'üîÑ Building accommodation screen - isLoading: $_isLoading, selectedMap: ${_selectedMap?.name}, rooms: ${_rooms.length}',
    );
    return Scaffold(
      appBar: AppBar(
        title: const Text('‡∏à‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏û‡∏±‡∏Å'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        actions: [
          IconButton(
            icon: const Icon(Icons.bug_report),
            onPressed: () => Navigator.push(
              context,
              MaterialPageRoute(builder: (_) => const TestMapDisplayScreen()),
            ),
            tooltip: '‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà',
          ),
          IconButton(
            icon: const Icon(Icons.info_outline),
            onPressed: () => _showHelpDialog(),
            tooltip: '‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô',
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _selectedMap == null
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.map_outlined, size: 64, color: Colors.grey),
                  const SizedBox(height: 16),
                  const Text(
                    '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏±‡∏Å',
                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  const SizedBox(height: 8),
                  const Text(
                    '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏î‡∏ß‡∏¥‡∏ò‡∏µ‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á\n‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏û‡∏±‡∏Å',
                    textAlign: TextAlign.center,
                    style: TextStyle(color: Colors.grey),
                  ),
                  const SizedBox(height: 24),
                  ElevatedButton.icon(
                    onPressed: _createTestMapAndRooms,
                    icon: const Icon(Icons.add_business),
                    label: const Text('‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏î‡∏™‡∏≠‡∏ö'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.purple,
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 24,
                        vertical: 12,
                      ),
                    ),
                  ),
                  const SizedBox(height: 12),
                  TextButton(
                    onPressed: () => Navigator.pop(context),
                    child: const Text('‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏ô‡∏π "‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏±‡∏Å"'),
                  ),
                ],
              ),
            )
          : Column(
              children: [
                // Date Picker
                Container(
                  padding: const EdgeInsets.all(16),
                  color: Colors.grey[100],
                  child: Row(
                    children: [
                      const Icon(Icons.calendar_today, color: Colors.purple),
                      const SizedBox(width: 8),
                      const Text(
                        '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ',
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
                      Text(
                        DateFormat('dd/MM/yyyy', 'th').format(_selectedDate),
                      ),
                      const Spacer(),
                      ElevatedButton.icon(
                        onPressed: () async {
                          final picked = await showDatePicker(
                            context: context,
                            initialDate: _selectedDate,
                            firstDate: DateTime.now(),
                            lastDate: DateTime.now().add(
                              const Duration(days: 365),
                            ),
                            locale: const Locale('th'),
                          );
                          if (picked != null && picked != _selectedDate) {
                            setState(() => _selectedDate = picked);
                            await _updateRoomStatusForDate(picked);
                          }
                        },
                        icon: const Icon(Icons.edit_calendar),
                        label: const Text('‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô'),
                      ),
                    ],
                  ),
                ),

                // Instructions and Legend
                Container(
                  padding: const EdgeInsets.all(16),
                  color: Colors.blue[50],
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          const Icon(Icons.info, color: Colors.blue, size: 20),
                          const SizedBox(width: 8),
                          const Text(
                            '‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: ‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏≠‡∏á',
                            style: TextStyle(
                              fontWeight: FontWeight.bold,
                              color: Colors.blue,
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Wrap(
                        spacing: 16,
                        runSpacing: 8,
                        children: [
                          _buildLegendItem(Colors.green, '‡∏´‡πâ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á (‡∏Ñ‡∏•‡∏¥‡∏Å‡πÑ‡∏î‡πâ)'),
                          _buildLegendItem(Colors.red, '‡∏°‡∏µ‡∏ú‡∏π‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å'),
                          _buildLegendItem(Colors.orange, '‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß'),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Text(
                        '‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: ${_rooms.length} ‡∏´‡πâ‡∏≠‡∏á | '
                        '‡∏´‡πâ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á: ${_rooms.where((r) => r.status == RoomStatus.available).length} ‡∏´‡πâ‡∏≠‡∏á',
                        style: const TextStyle(
                          fontSize: 12,
                          color: Colors.grey,
                        ),
                      ),
                    ],
                  ),
                ),

                // Map
                Expanded(
                  child: Column(
                    children: [
                      // ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏£‡∏¥‡∏á
                      Expanded(
                        child: MapViewer(
                          mapData: _selectedMap!,
                          rooms: _rooms,
                          onRoomTap: _onRoomTapped,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
    );
  }

  Future<void> _createTestMapAndRooms() async {
    try {
      // ‡πÅ‡∏™‡∏î‡∏á loading dialog
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(
          child: Card(
            child: Padding(
              padding: EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏î‡∏™‡∏≠‡∏ö...'),
                ],
              ),
            ),
          ),
        ),
      );

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏±‡∏Å
      await _mapService.createTestData();

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏° (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ)
      await _dbHelper.createTestData();

      // ‡∏õ‡∏¥‡∏î loading dialog
      if (mounted) Navigator.pop(context);

      // ‡∏£‡∏µ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
      await _loadMapAndRooms();

      // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      // ‡∏õ‡∏¥‡∏î loading dialog ‡∏´‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà
      if (mounted) Navigator.pop(context);

      // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° error
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }

      debugPrint('Error creating test data: $e');
    }
  }

  void _showHelpDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.help_outline, color: Colors.blue),
            SizedBox(width: 8),
            Text('‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô'),
          ],
        ),
        content: const SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                '‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏û‡∏±‡∏Å:',
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
              ),
              SizedBox(height: 8),
              Text('1. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á'),
              Text('2. ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß (‡∏´‡πâ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á)'),
              Text('3. ‡∏Å‡∏£‡∏≠‡∏Å‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô 13 ‡∏´‡∏•‡∏±‡∏Å'),
              Text('4. ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á'),
              SizedBox(height: 16),
              Text(
                '‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á:',
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
              ),
              SizedBox(height: 8),
              Text('‚Ä¢ ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏π‡πâ‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ò‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡πâ‡∏ß'),
              Text('‚Ä¢ ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î'),
              Text('‚Ä¢ ‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ñ‡∏ô‡∏à‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏ï‡πà‡∏≠‡∏ß‡∏±‡∏ô'),
              Text('‚Ä¢ ‡∏´‡πâ‡∏≠‡∏á‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏Ñ‡∏∑‡∏≠‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ú‡∏π‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏û‡∏±‡∏Å‡πÅ‡∏•‡πâ‡∏ß'),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÅ‡∏•‡πâ‡∏ß'),
          ),
        ],
      ),
    );
  }

  Widget _buildLegendItem(Color color, String label) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 16,
          height: 16,
          decoration: BoxDecoration(
            color: color,
            shape: BoxShape.circle,
            border: Border.all(color: Colors.black26),
          ),
        ),
        const SizedBox(width: 4),
        Text(label, style: const TextStyle(fontSize: 12)),
      ],
    );
  }
}
