import 'dart:io';
import 'dart:async';
import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';
import 'db_helper.dart';
import 'backup_exceptions.dart';

/// Performance-optimized SQL export service for large datasets
/// Implements streaming and batch processing for efficient memory usage
class PerformanceOptimizedSqlExportService {
  final DbHelper _dbHelper = DbHelper();
  
  // Performance configuration
  static const int _batchSize = 1000;
  static const int _insertBatchSize = 500; // Smaller batches for INSERT statements
  
  /// Export to SQL with streaming for large datasets
  Future<String> exportToSqlStreaming({
    Function(double)? onProgress,
    Function(String)? onStatusUpdate,
  }) async {
    try {
      await _dbHelper.db; // Ensure database is initialized
      
      final fileName = generateTimestampedFileName();
      final directory = await _getBackupDirectory();
      final filePath = '${directory.path}/$fileName';
      final file = File(filePath);
      
      final sink = file.openWrite();
      
      try {
        await _writeSqlStreamingFormat(
          sink,
          onProgress: onProgress,
          onStatusUpdate: onStatusUpdate,
        );
        
        await sink.flush();
        await sink.close();
        
        onStatusUpdate?.call('SQL export completed successfully');
        onProgress?.call(1.0);
        
        return filePath;
      } finally {
        await sink.close();
      }
    } catch (e) {
      throw BackupException(
        'Failed to export SQL with streaming: ${e.toString()}',
        code: 'SQL_STREAMING_EXPORT_ERROR',
        originalError: e,
      );
    }
  }

  /// Write SQL in streaming format
  Future<void> _writeSqlStreamingFormat(
    IOSink sink, {
    Function(double)? onProgress,
    Function(String)? onStatusUpdate,
  }) async {
    final database = await _dbHelper.db;
    
    // Write header
    onStatusUpdate?.call('Writing SQL header...');
    sink.writeln('-- Backup created on ${DateTime.now().toIso8601String()}');
    sink.writeln('-- Database version: 9');
    sink.writeln('-- Generated by PerformanceOptimizedSqlExportService');
    sink.writeln('-- Export method: streaming with batching');
    sink.writeln();
    
    onProgress?.call(0.1);
    
    // Write DROP statements
    onStatusUpdate?.call('Writing DROP statements...');
    await _writeDropStatements(sink);
    onProgress?.call(0.2);
    
    // Write CREATE statements
    onStatusUpdate?.call('Writing CREATE statements...');
    await _writeCreateStatements(sink);
    onProgress?.call(0.3);
    
    // Write INDEX statements
    onStatusUpdate?.call('Writing INDEX statements...');
    await _writeIndexStatements(sink);
    onProgress?.call(0.4);
    
    // Write INSERT statements with streaming
    onStatusUpdate?.call('Writing INSERT statements...');
    await _writeInsertStatementsStreaming(
      database, 
      sink,
      onProgress: (insertProgress) {
        onProgress?.call(0.4 + (insertProgress * 0.6)); // 40% to 100%
      },
      onStatusUpdate: onStatusUpdate,
    );
  }

  /// Write DROP statements
  Future<void> _writeDropStatements(IOSink sink) async {
    sink.writeln('-- Drop existing tables');
    
    final tables = [
      'room_bookings',
      'rooms',
      'maps',
      'reg_additional_info',
      'stays',
      'regs',
      'app_settings',
    ];

    for (final table in tables) {
      sink.writeln('DROP TABLE IF EXISTS $table;');
    }
    sink.writeln();
    await sink.flush();
  }

  /// Write CREATE statements
  Future<void> _writeCreateStatements(IOSink sink) async {
    sink.writeln('-- Create tables');
    
    // Write all CREATE TABLE statements
    final createStatements = await _generateCreateTableStatements();
    sink.write(createStatements);
    sink.writeln();
    await sink.flush();
  }

  /// Write INDEX statements
  Future<void> _writeIndexStatements(IOSink sink) async {
    sink.writeln('-- Create indexes');
    
    final indexStatements = await _generateIndexStatements();
    sink.write(indexStatements);
    sink.writeln();
    await sink.flush();
  }

  /// Write INSERT statements with streaming and batching
  Future<void> _writeInsertStatementsStreaming(
    Database database,
    IOSink sink, {
    Function(double)? onProgress,
    Function(String)? onStatusUpdate,
  }) async {
    sink.writeln('-- Insert data');
    
    final tables = [
      'regs',
      'app_settings',
      'maps',
      'rooms',
      'stays',
      'reg_additional_info',
      'room_bookings',
    ];

    // Get total record count for progress tracking
    int totalRecords = 0;
    final tableCounts = <String, int>{};
    
    for (final tableName in tables) {
      final count = await _getTableRecordCount(database, tableName);
      tableCounts[tableName] = count;
      totalRecords += count;
    }
    
    int processedRecords = 0;
    
    for (final tableName in tables) {
      final tableCount = tableCounts[tableName] ?? 0;
      if (tableCount == 0) continue;
      
      onStatusUpdate?.call('Exporting table: $tableName ($tableCount records)');
      
      sink.writeln('-- Data for table: $tableName');
      
      // Export table data in batches
      int offset = 0;
      while (offset < tableCount) {
        final batch = await database.query(
          tableName,
          limit: _insertBatchSize,
          offset: offset,
          orderBy: _getPrimaryKeyColumn(tableName),
        );
        
        if (batch.isEmpty) break;
        
        // Write batch as optimized INSERT statements
        await _writeBatchInserts(sink, tableName, batch);
        
        processedRecords += batch.length;
        offset += _insertBatchSize;
        
        // Update progress
        onProgress?.call(processedRecords / totalRecords);
        
        // Flush periodically
        if (offset % (_insertBatchSize * 5) == 0) {
          await sink.flush();
        }
      }
      
      sink.writeln();
    }
    
    await sink.flush();
  }

  /// Write batch of INSERT statements optimized for performance
  Future<void> _writeBatchInserts(
    IOSink sink,
    String tableName,
    List<Map<String, dynamic>> batch,
  ) async {
    if (batch.isEmpty) return;
    
    // Get column names from first record
    final columns = batch.first.keys.toList();
    final columnsStr = columns.join(', ');
    
    // Use multi-row INSERT for better performance
    sink.write('INSERT INTO $tableName ($columnsStr) VALUES ');
    
    for (int i = 0; i < batch.length; i++) {
      if (i > 0) sink.write(', ');
      
      final values = columns.map((column) {
        final value = batch[i][column];
        if (value == null) {
          return 'NULL';
        } else if (value is String) {
          // Escape single quotes and handle special characters
          final escapedValue = value
              .replaceAll('\\', '\\\\')
              .replaceAll("'", "''")
              .replaceAll('\n', '\\n')
              .replaceAll('\r', '\\r')
              .replaceAll('\t', '\\t');
          return "'$escapedValue'";
        } else {
          return value.toString();
        }
      }).join(', ');
      
      sink.write('($values)');
    }
    
    sink.writeln(';');
  }

  /// Get record count for specific table
  Future<int> _getTableRecordCount(Database database, String tableName) async {
    try {
      final tableExists = await _checkTableExists(database, tableName);
      if (!tableExists) {
        return 0;
      }
      
      final result = await database.rawQuery('SELECT COUNT(*) as count FROM $tableName');
      return result.first['count'] as int;
    } catch (e) {
      return 0;
    }
  }

  /// Check if table exists
  Future<bool> _checkTableExists(Database database, String tableName) async {
    try {
      final result = await database.rawQuery(
        "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
        [tableName],
      );
      return result.isNotEmpty;
    } catch (e) {
      return false;
    }
  }

  /// Get primary key column for consistent ordering
  String _getPrimaryKeyColumn(String tableName) {
    switch (tableName) {
      case 'regs':
        return 'id';
      case 'stays':
      case 'reg_additional_info':
      case 'maps':
      case 'rooms':
      case 'room_bookings':
        return 'id';
      case 'app_settings':
        return 'key';
      default:
        return 'rowid';
    }
  }

  /// Generate CREATE TABLE statements (same as original but optimized)
  Future<String> _generateCreateTableStatements() async {
    final createStatements = StringBuffer();

    // Optimized table creation with proper constraints and indexes
    createStatements.writeln('''CREATE TABLE regs (
  id TEXT PRIMARY KEY,
  first TEXT,
  last TEXT,
  dob TEXT,
  phone TEXT,
  addr TEXT,
  gender TEXT,
  hasIdCard INTEGER,
  status TEXT DEFAULT 'A',
  createdAt TEXT,
  updatedAt TEXT
);''');
    createStatements.writeln();

    createStatements.writeln('''CREATE TABLE reg_additional_info (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  regId TEXT NOT NULL,
  visitId TEXT NOT NULL,
  startDate TEXT,
  endDate TEXT,
  shirtCount INTEGER DEFAULT 0,
  pantsCount INTEGER DEFAULT 0,
  matCount INTEGER DEFAULT 0,
  pillowCount INTEGER DEFAULT 0,
  blanketCount INTEGER DEFAULT 0,
  location TEXT,
  withChildren INTEGER DEFAULT 0,
  childrenCount INTEGER DEFAULT 0,
  notes TEXT,
  createdAt TEXT,
  updatedAt TEXT,
  FOREIGN KEY (regId) REFERENCES regs (id) ON DELETE CASCADE,
  UNIQUE(regId, visitId)
);''');
    createStatements.writeln();

    createStatements.writeln('''CREATE TABLE stays (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  visitor_id TEXT NOT NULL,
  start_date TEXT NOT NULL,
  end_date TEXT NOT NULL,
  status TEXT DEFAULT 'active',
  note TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (visitor_id) REFERENCES regs (id) ON DELETE CASCADE
);''');
    createStatements.writeln();

    createStatements.writeln('''CREATE TABLE app_settings (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);''');
    createStatements.writeln();

    createStatements.writeln('''CREATE TABLE maps (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  image_path TEXT,
  image_width REAL,
  image_height REAL,
  is_active INTEGER DEFAULT 0,
  description TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL
);''');
    createStatements.writeln();

    createStatements.writeln('''CREATE TABLE rooms (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  size TEXT NOT NULL,
  shape TEXT DEFAULT 'square',
  capacity INTEGER NOT NULL,
  position_x REAL,
  position_y REAL,
  status TEXT DEFAULT 'available',
  description TEXT,
  current_occupant TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (current_occupant) REFERENCES regs (id) ON DELETE SET NULL
);''');
    createStatements.writeln();

    createStatements.writeln('''CREATE TABLE room_bookings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  room_id INTEGER NOT NULL,
  visitor_id TEXT NOT NULL,
  check_in_date TEXT NOT NULL,
  check_out_date TEXT NOT NULL,
  status TEXT DEFAULT 'pending',
  note TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (room_id) REFERENCES rooms (id) ON DELETE CASCADE,
  FOREIGN KEY (visitor_id) REFERENCES regs (id) ON DELETE CASCADE
);''');

    return createStatements.toString();
  }

  /// Generate INDEX statements optimized for performance
  Future<String> _generateIndexStatements() async {
    final indexStatements = StringBuffer();

    // Performance-critical indexes
    indexStatements.writeln('-- Performance indexes for regs table');
    indexStatements.writeln('CREATE INDEX idx_regs_phone ON regs(phone);');
    indexStatements.writeln('CREATE INDEX idx_regs_status ON regs(status);');
    indexStatements.writeln('CREATE INDEX idx_regs_created_at ON regs(createdAt);');
    indexStatements.writeln();

    indexStatements.writeln('-- Performance indexes for stays table');
    indexStatements.writeln('CREATE INDEX idx_stays_visitor_id ON stays(visitor_id);');
    indexStatements.writeln('CREATE INDEX idx_stays_date_range ON stays(start_date, end_date);');
    indexStatements.writeln('CREATE INDEX idx_stays_status ON stays(status);');
    indexStatements.writeln();

    indexStatements.writeln('-- Performance indexes for reg_additional_info table');
    indexStatements.writeln('CREATE INDEX idx_reg_additional_info_regId ON reg_additional_info(regId);');
    indexStatements.writeln('CREATE INDEX idx_reg_additional_info_visitId ON reg_additional_info(visitId);');
    indexStatements.writeln('CREATE INDEX idx_reg_additional_info_dates ON reg_additional_info(startDate, endDate);');
    indexStatements.writeln();

    indexStatements.writeln('-- Performance indexes for rooms table');
    indexStatements.writeln('CREATE INDEX idx_rooms_status ON rooms(status);');
    indexStatements.writeln('CREATE INDEX idx_rooms_position ON rooms(position_x, position_y);');
    indexStatements.writeln('CREATE INDEX idx_rooms_occupant ON rooms(current_occupant);');
    indexStatements.writeln();

    indexStatements.writeln('-- Performance indexes for room_bookings table');
    indexStatements.writeln('CREATE INDEX idx_room_bookings_room_id ON room_bookings(room_id);');
    indexStatements.writeln('CREATE INDEX idx_room_bookings_visitor_id ON room_bookings(visitor_id);');
    indexStatements.writeln('CREATE INDEX idx_room_bookings_dates ON room_bookings(check_in_date, check_out_date);');
    indexStatements.writeln('CREATE INDEX idx_room_bookings_status ON room_bookings(status);');

    return indexStatements.toString();
  }

  /// Generate timestamped filename
  String generateTimestampedFileName() {
    final now = DateTime.now();
    return 'backup_optimized_${now.year}-${now.month.toString().padLeft(2, '0')}-${now.day.toString().padLeft(2, '0')}_${now.hour.toString().padLeft(2, '0')}-${now.minute.toString().padLeft(2, '0')}-${now.second.toString().padLeft(2, '0')}.sql';
  }

  /// Generate daily backup filename
  String generateDailyBackupFileName() {
    final now = DateTime.now();
    return '${now.day.toString().padLeft(2, '0')}_optimized.sql';
  }

  /// Get backup directory
  Future<Directory> _getBackupDirectory() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final backupDir = Directory('${directory.path}/backups');
      
      if (!await backupDir.exists()) {
        await backupDir.create(recursive: true);
      }
      
      return backupDir;
    } catch (e) {
      throw BackupException(
        'Failed to access backup directory: ${e.toString()}',
        code: 'DIRECTORY_ACCESS_ERROR',
        originalError: e,
      );
    }
  }

  /// Export daily backup with optimization
  Future<String> exportDailyBackupOptimized({
    Function(double)? onProgress,
    Function(String)? onStatusUpdate,
  }) async {
    try {
      final fileName = generateDailyBackupFileName();
      final directory = await _getBackupDirectory();
      final filePath = '${directory.path}/$fileName';
      final file = File(filePath);
      
      final sink = file.openWrite();
      
      try {
        await _writeSqlStreamingFormat(
          sink,
          onProgress: onProgress,
          onStatusUpdate: onStatusUpdate,
        );
        
        await sink.flush();
        await sink.close();
        
        return filePath;
      } finally {
        await sink.close();
      }
    } catch (e) {
      throw BackupException(
        'Failed to create optimized daily backup: ${e.toString()}',
        code: 'DAILY_BACKUP_OPTIMIZED_ERROR',
        originalError: e,
      );
    }
  }
}