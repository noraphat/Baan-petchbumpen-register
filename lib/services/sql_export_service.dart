import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';
import 'db_helper.dart';
import 'backup_exceptions.dart';

/// Service สำหรับ export ข้อมูลเป็น SQL format
/// ใช้สำหรับ auto backup รายวัน
class SqlExportService {
  final DbHelper _dbHelper = DbHelper();

  /// Export ข้อมูลทั้งหมดเป็น SQL format
  Future<String> exportToSql() async {
    try {
      await _dbHelper.db; // Ensure database is initialized
      final sqlContent = StringBuffer();

      // เพิ่ม header comment
      sqlContent.writeln('-- Backup created on ${DateTime.now().toIso8601String()}');
      sqlContent.writeln('-- Database version: 9');
      sqlContent.writeln('-- Generated by SqlExportService');
      sqlContent.writeln();

      // สร้าง DROP TABLE statements
      final dropStatements = await _generateDropTableStatements();
      sqlContent.writeln('-- Drop existing tables');
      sqlContent.writeln(dropStatements);
      sqlContent.writeln();

      // สร้าง CREATE TABLE statements
      final createStatements = await _generateCreateTableStatements();
      sqlContent.writeln('-- Create tables');
      sqlContent.writeln(createStatements);
      sqlContent.writeln();

      // สร้าง INDEX statements
      final indexStatements = await _generateIndexStatements();
      sqlContent.writeln('-- Create indexes');
      sqlContent.writeln(indexStatements);
      sqlContent.writeln();

      // สร้าง INSERT statements
      final insertStatements = await _generateInsertStatements();
      sqlContent.writeln('-- Insert data');
      sqlContent.writeln(insertStatements);

      return sqlContent.toString();
    } catch (e) {
      throw BackupException('Failed to export SQL: ${e.toString()}');
    }
  }

  /// สร้าง DROP TABLE statements
  Future<String> _generateDropTableStatements() async {
    final dropStatements = StringBuffer();
    
    // ลำดับการลบตาราง (ต้องลบ foreign key tables ก่อน)
    final tables = [
      'room_bookings',
      'rooms',
      'maps',
      'reg_additional_info',
      'stays',
      'regs',
      'app_settings',
    ];

    for (final table in tables) {
      dropStatements.writeln('DROP TABLE IF EXISTS $table;');
    }

    return dropStatements.toString();
  }

  /// สร้าง CREATE TABLE statements พร้อม schema
  Future<String> _generateCreateTableStatements() async {
    final createStatements = StringBuffer();

    // ตาราง regs (ข้อมูลหลัก)
    createStatements.writeln('''CREATE TABLE regs (
  id TEXT PRIMARY KEY,
  first TEXT,
  last TEXT,
  dob TEXT,
  phone TEXT,
  addr TEXT,
  gender TEXT,
  hasIdCard INTEGER,
  status TEXT DEFAULT 'A',
  createdAt TEXT,
  updatedAt TEXT
);''');
    createStatements.writeln();

    // ตาราง reg_additional_info
    createStatements.writeln('''CREATE TABLE reg_additional_info (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  regId TEXT NOT NULL,
  visitId TEXT NOT NULL,
  startDate TEXT,
  endDate TEXT,
  shirtCount INTEGER DEFAULT 0,
  pantsCount INTEGER DEFAULT 0,
  matCount INTEGER DEFAULT 0,
  pillowCount INTEGER DEFAULT 0,
  blanketCount INTEGER DEFAULT 0,
  location TEXT,
  withChildren INTEGER DEFAULT 0,
  childrenCount INTEGER DEFAULT 0,
  notes TEXT,
  createdAt TEXT,
  updatedAt TEXT,
  FOREIGN KEY (regId) REFERENCES regs (id) ON DELETE CASCADE,
  UNIQUE(regId, visitId)
);''');
    createStatements.writeln();

    // ตาราง stays
    createStatements.writeln('''CREATE TABLE stays (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  visitor_id TEXT NOT NULL,
  start_date TEXT NOT NULL,
  end_date TEXT NOT NULL,
  status TEXT DEFAULT 'active',
  note TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (visitor_id) REFERENCES regs (id) ON DELETE CASCADE
);''');
    createStatements.writeln();

    // ตาราง app_settings
    createStatements.writeln('''CREATE TABLE app_settings (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);''');
    createStatements.writeln();

    // ตาราง maps
    createStatements.writeln('''CREATE TABLE maps (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  image_path TEXT,
  image_width REAL,
  image_height REAL,
  is_active INTEGER DEFAULT 0,
  description TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL
);''');
    createStatements.writeln();

    // ตาราง rooms
    createStatements.writeln('''CREATE TABLE rooms (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  size TEXT NOT NULL,
  shape TEXT DEFAULT 'square',
  capacity INTEGER NOT NULL,
  position_x REAL,
  position_y REAL,
  status TEXT DEFAULT 'available',
  description TEXT,
  current_occupant TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (current_occupant) REFERENCES regs (id) ON DELETE SET NULL
);''');
    createStatements.writeln();

    // ตาราง room_bookings
    createStatements.writeln('''CREATE TABLE room_bookings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  room_id INTEGER NOT NULL,
  visitor_id TEXT NOT NULL,
  check_in_date TEXT NOT NULL,
  check_out_date TEXT NOT NULL,
  status TEXT DEFAULT 'pending',
  note TEXT,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (room_id) REFERENCES rooms (id) ON DELETE CASCADE,
  FOREIGN KEY (visitor_id) REFERENCES regs (id) ON DELETE CASCADE
);''');

    return createStatements.toString();
  }

  /// สร้าง INDEX statements
  Future<String> _generateIndexStatements() async {
    final indexStatements = StringBuffer();

    // Indexes สำหรับ stays table
    indexStatements.writeln('CREATE INDEX idx_stays_visitor_id ON stays(visitor_id);');
    indexStatements.writeln('CREATE INDEX idx_stays_date_range ON stays(start_date, end_date);');
    indexStatements.writeln();

    // Indexes สำหรับ rooms table
    indexStatements.writeln('CREATE INDEX idx_rooms_status ON rooms(status);');
    indexStatements.writeln('CREATE INDEX idx_rooms_position ON rooms(position_x, position_y);');
    indexStatements.writeln();

    // Indexes สำหรับ room_bookings table
    indexStatements.writeln('CREATE INDEX idx_room_bookings_room_id ON room_bookings(room_id);');
    indexStatements.writeln('CREATE INDEX idx_room_bookings_visitor_id ON room_bookings(visitor_id);');
    indexStatements.writeln('CREATE INDEX idx_room_bookings_dates ON room_bookings(check_in_date, check_out_date);');

    return indexStatements.toString();
  }

  /// สร้าง INSERT statements สำหรับข้อมูลทั้งหมด
  Future<String> _generateInsertStatements() async {
    final database = await _dbHelper.db;
    final insertStatements = StringBuffer();

    // ลำดับการ insert (ต้อง insert parent tables ก่อน)
    final tables = [
      'regs',
      'app_settings',
      'maps',
      'rooms',
      'stays',
      'reg_additional_info',
      'room_bookings',
    ];

    for (final tableName in tables) {
      final tableData = await _exportTableData(database, tableName);
      if (tableData.isNotEmpty) {
        insertStatements.writeln('-- Data for table: $tableName');
        insertStatements.writeln(tableData);
        insertStatements.writeln();
      }
    }

    return insertStatements.toString();
  }

  /// Export ข้อมูลจากตารางเฉพาะ
  Future<String> _exportTableData(Database database, String tableName) async {
    try {
      final results = await database.query(tableName);
      if (results.isEmpty) {
        return '-- No data in table: $tableName';
      }

      final insertStatements = StringBuffer();
      
      for (final row in results) {
        final columns = row.keys.toList();
        final values = row.values.map((value) {
          if (value == null) {
            return 'NULL';
          } else if (value is String) {
            // Escape single quotes in strings
            final escapedValue = value.replaceAll("'", "''");
            return "'$escapedValue'";
          } else {
            return value.toString();
          }
        }).toList();

        final columnsStr = columns.join(', ');
        final valuesStr = values.join(', ');
        
        insertStatements.writeln('INSERT INTO $tableName ($columnsStr) VALUES ($valuesStr);');
      }

      return insertStatements.toString();
    } catch (e) {
      throw BackupException('Failed to export table $tableName: ${e.toString()}');
    }
  }

  /// บันทึก SQL content ลงไฟล์
  Future<String> saveSqlToFile(String sqlContent, String fileName) async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final backupDir = Directory('${directory.path}/backups');
      
      // สร้าง backup directory ถ้ายังไม่มี
      if (!await backupDir.exists()) {
        await backupDir.create(recursive: true);
      }

      final file = File('${backupDir.path}/$fileName');
      await file.writeAsString(sqlContent);
      
      return file.path;
    } catch (e) {
      throw BackupException('Failed to save SQL file: ${e.toString()}');
    }
  }

  /// สร้างชื่อไฟล์ SQL สำหรับ daily backup (รูปแบบ DD.sql)
  String generateDailyBackupFileName() {
    final now = DateTime.now();
    return '${now.day.toString().padLeft(2, '0')}.sql';
  }

  /// สร้างชื่อไฟล์ SQL พร้อม timestamp
  String generateTimestampedFileName() {
    final now = DateTime.now();
    return 'backup_${now.year}-${now.month.toString().padLeft(2, '0')}-${now.day.toString().padLeft(2, '0')}_${now.hour.toString().padLeft(2, '0')}-${now.minute.toString().padLeft(2, '0')}-${now.second.toString().padLeft(2, '0')}.sql';
  }

  /// Export และบันทึกไฟล์ SQL สำหรับ daily backup
  Future<String> exportDailyBackup() async {
    try {
      final sqlContent = await exportToSql();
      final fileName = generateDailyBackupFileName();
      final filePath = await saveSqlToFile(sqlContent, fileName);
      
      return filePath;
    } catch (e) {
      throw BackupException('Failed to create daily backup: ${e.toString()}');
    }
  }

  /// Export และบันทึกไฟล์ SQL พร้อม timestamp
  Future<String> exportTimestampedBackup() async {
    try {
      final sqlContent = await exportToSql();
      final fileName = generateTimestampedFileName();
      final filePath = await saveSqlToFile(sqlContent, fileName);
      
      return filePath;
    } catch (e) {
      throw BackupException('Failed to create timestamped backup: ${e.toString()}');
    }
  }
}